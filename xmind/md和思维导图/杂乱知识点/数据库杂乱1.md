# 原理部分

## 解析过程

1. 语法检查
2. 语义检查
3. 对sql进行解析，利用内部算法对sql进行解析，生成解析树（parse tree）以及执行计划（execution plan）
4. 执行 sql，返回结果



## 解析过程详解

### 语法检查

判断语句是否符合sql规范，比如select 是否拼写正确

### 语义检查

判断SQL语句所访问的表以及列是否正确

### 解析

1. hard parse
2. soft parse
3. soft soft parse

Hard parse ：

1. 语法
2. 权限和对象检查
3. 在共享池中检查是否有完全相同的之间解析好的，如果存在，直接跳过4,5，运行sql，此时算soft parse
4. 选择执行计划
5. 产生执行计划



### 解析的步骤

1）验证SQL语句是否完全一致

将传进来的SQL语句进行HASH函数计算，，再和共享池中的现有语句HASH值 

如果SQL语句的hash值一致，那么还需要再次检测，可能存在不同用户在各自有一张名为emp的表，执行select * from emp；

2）同样一条SQL语句，一个添加 first_rows Hint，一个添加 all_rows Hint产生的执行计划也是不同的

### 绑定变量

通过绑定变量，避免产生硬解析







# 查询优化

1. 代数优化
2. 物理优化

## 选择操作的实现

（1）简单的全表扫描算法

（2）索引扫描

找出满足条件的元组指针，再在基本表上找到元组

## 连接操作的实现

#### （1）嵌套循环算法

#### （2）排序合并算法

1 如果参与链接的表没有排序，按照链接的属性排序 例如Student表 连 SC表，都按照Sno排序

2 从Student表取第一个Sno，依次扫描SC表，连接起来

3 扫到不同时，或者SC表所在行比Student sno 大时，在从Student 取下一个元素

#### （3）索引链接

 步骤

1SC表已建立属性Sno的索引

2 在Student中每一个元组，由Sno值通过SC的索引找到相应的SC元组

3 把这些SC元组和Student

#### （4）hash join







*一个语句转成不同的代数表达式，执行性能也是不一样的*

### 代数优化

#### 查询树的启发式优化

- 选择运算应可能先做
- 把投影运算和选择运算同时进行
- 把投影同其前或后的双目运算结合起来
- 把某些笛卡尔积结合起来成为一个连接运算
- 找出公共子表达式



## 树的实际实现

邻接模型

物化路径模型

嵌套模型





## MVCC

> https://www.cnblogs.com/chenpingzhao/p/5065316.html

每行记录后面有两个字段 创建时间（事务的ID） 删除时间（事务ID）

DATA_TRX_ID(系统事务版本ID) 理解为创建时间·

DATA_ROLL_PTR 指向当前记录的rollback 的 undo log，找回之前的版本

DELETE BIT 标注是否被删除  理解为删除时间



### select

Innodb检查每行数据，确保他们符合两个标准

1. 只查找版本早于点钱事务版本的数据行
2. 行的删除操作一定是未定义的或者大于点钱事务的版本

才会返回结果

### INSERT

事务版本ID为当前事务的ID

创建时间 = DB_ROW_ID ;删除时间 未定义

### DELETE

当前系统版本号为行的删除ID 

删除时间=DB_ROW_ID 创建时间不变

### UPDATE

innodb复制一行 使用新的版本号

新行 的创建时间=DB_ROW_ID  删除时间 未定义

旧行 创建时间 不变 删除时间=该事物的DB_ROW_ID





## 并发调度可串行化

## 可串行化调度

多个事务的并发执行的正确，当且仅当其结果与按某一次序串行地执行这些结果相同，称这种调度策略为*可串行化调度*









